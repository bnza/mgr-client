import { writeFileSync, mkdirSync } from 'node:fs'
import { dirname } from 'node:path'
import dotenv from 'dotenv'

dotenv.config()

const apiBaseUrl = process.env.NUXT_PUBLIC_API_BASE_URL
if (!apiBaseUrl) {
  console.error('NUXT_PUBLIC_API_BASE_URL is not defined in your .env file.')
  process.exit(1)
}

const indexUrl = `${apiBaseUrl}/api/index.jsonld`
const openApiUrl = `${apiBaseUrl}/api/docs.jsonopenapi`

console.log(`Fetching API index from: ${indexUrl}`)

try {
  // Fetch the API index
  const response = await fetch(indexUrl)

  if (!response.ok) {
    console.error(`HTTP error! status: ${response.status}`)
    process.exit(1)
  }

  const data = (await response.json()) as Record<string, string>

  // Extract entries that don't start with '@'
  const resourceEntries = Object.entries(data).filter(
    ([key]) => !key.startsWith('@'),
  )

  if (resourceEntries.length === 0) {
    console.warn("No resource entries found (all keys start with '@')")
    process.exit(0)
  }

  // Generate API_RESOURCE_MAP object
  const resourceMapEntries = resourceEntries
    .map(([key, value]) => `  ${key}: '${value}'`)
    .join(',\n')

  // Fetch OpenAPI spec to build API_FEATURES_RESOURCE_MAP
  console.log(`Fetching OpenAPI spec from: ${openApiUrl}`)
  const openApiResponse = await fetch(openApiUrl)
  if (!openApiResponse.ok) {
    console.error(
      `HTTP error fetching OpenAPI! status: ${openApiResponse.status}`,
    )
    process.exit(1)
  }
  const openApi = (await openApiResponse.json()) as any

  type PathItem = {
    get?: {
      tags?: string[]
      responses?: {
        200?: { content?: Record<string, unknown> }
      }
    }
  }

  const paths: Record<string, PathItem> = openApi.paths || {}

  // Set of known API resource paths from the index
  const apiResourcePaths = new Set(
    Object.values(Object.fromEntries(resourceEntries)),
  )

  const isApiResourcePath = (p: string) => apiResourcePaths.has(p)

  const hasGeoJson200 = (pi?: PathItem) => {
    const content = pi?.get?.responses?.[200]?.content
    return (
      content &&
      Object.prototype.hasOwnProperty.call(content, 'application/geo+json')
    )
  }

  const getTags = (p: string) => paths[p]?.get?.tags || []

  const featurePaths = Object.keys(paths).filter((p) => hasGeoJson200(paths[p]))

  const candidateResourcePaths = Array.from(apiResourcePaths).filter(
    (p): p is string => typeof p === 'string' && Boolean(paths[p]?.get),
  )

  const intersect = (a: string[], b: string[]) => a.filter((t) => b.includes(t))

  const featuresResourceEntries: [string, string][] = []
  for (const featPath of featurePaths) {
    const featTags = getTags(featPath)
    const matches = candidateResourcePaths
      .map((rp) => ({ rp, score: intersect(getTags(rp), featTags).length }))
      .filter((x) => x.score > 0)
      .sort((a, b) => b.score - a.score)

    const best = matches[0]?.rp
    if (best && isApiResourcePath(best)) {
      featuresResourceEntries.push([featPath, best])
    }
  }

  // Sort entries for stable output
  featuresResourceEntries.sort((a, b) => a[0].localeCompare(b[0]))

  const featuresMapEntries = featuresResourceEntries
    .map(([key, value]) => `  '${key}': '${value}'`)
    .join(',\n')

  const extendsFeatureCollectionClause = '<P extends GetFeatureCollectionPath>'
  const satisfiesClause = 'Record<GetFeatureCollectionPath, GetCollectionPath>'
  const templateString =
    'Extract<GetItemPath, `${FeaturePathToApiResourcePath<P>}/{id}`>'

  const tsContent = `// Auto-generated from API index at ${indexUrl}
// Do not edit this file manually

import type { GetCollectionPath, GetFeatureCollectionPath, GetItemPath } from '~~/types'

export const API_RESOURCE_MAP = {
${resourceMapEntries}
} as const

export type ApiResourceKey = keyof typeof API_RESOURCE_MAP

export type ApiResourcePath =
  (typeof API_RESOURCE_MAP)[keyof typeof API_RESOURCE_MAP]

// Map of feature collection endpoints (GeoJSON) to their related API resource collection path
// Keys are OpenAPI paths that return 200 with 'application/geo+json'
export const API_FEATURES_RESOURCE_MAP = {
    ${featuresMapEntries}
} as const satisfies ${satisfiesClause}

type FeaturesMap = typeof API_FEATURES_RESOURCE_MAP
export type FeaturePathToApiResourcePath${extendsFeatureCollectionClause} = FeaturesMap[P]

// Type helper: map a GetFeatureCollectionPath to the corresponding GetItemPath
// by appending '/{id}' to the related ApiResourcePath, and intersecting with GetItemPath
export type FeaturePathToItemPath${extendsFeatureCollectionClause} =
${templateString}
`

  // Ensure directory exists
  const outputPath = './app/utils/consts/resources.ts'
  mkdirSync(dirname(outputPath), { recursive: true })

  // Write the file
  writeFileSync(outputPath, tsContent, 'utf8')

  console.log(
    `Generated ${outputPath} with ${resourceEntries.length} resource entries and ${featuresResourceEntries.length} feature mappings`,
  )
  console.log('Resource keys:', resourceEntries.map(([key]) => key).join(', '))
} catch (error) {
  const message = error instanceof Error ? error.message : String(error)
  console.error('Error generating resource index types:', message)
  process.exit(1)
}
